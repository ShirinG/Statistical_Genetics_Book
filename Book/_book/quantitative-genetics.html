<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Statistical Genetics Analyses in R</title>
  <meta name="description" content="Description to come…">
  <meta name="generator" content="bookdown 0.3.9 and GitBook 2.6.7">

  <meta property="og:title" content="Statistical Genetics Analyses in R" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Description to come…" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Statistical Genetics Analyses in R" />
  
  <meta name="twitter:description" content="Description to come…" />
  

<meta name="author" content="Dr. Shirin Glander">


<meta name="date" content="2017-02-08">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="introduction-to-statistical-genetics.html">
<link rel="next" href="population-genetics.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="chapter" data-level="" data-path="about-the-author.html"><a href="about-the-author.html"><i class="fa fa-check"></i>About the Author</a></li>
<li class="chapter" data-level="1" data-path="introduction-to-statistical-genetics.html"><a href="introduction-to-statistical-genetics.html"><i class="fa fa-check"></i><b>1</b> Introduction to Statistical Genetics</a></li>
<li class="chapter" data-level="2" data-path="quantitative-genetics.html"><a href="quantitative-genetics.html"><i class="fa fa-check"></i><b>2</b> Quantitative Genetics</a><ul>
<li class="chapter" data-level="2.1" data-path="quantitative-genetics.html"><a href="quantitative-genetics.html#qtl-analysis"><i class="fa fa-check"></i><b>2.1</b> QTL analysis</a><ul>
<li class="chapter" data-level="2.1.1" data-path="quantitative-genetics.html"><a href="quantitative-genetics.html#recombinant-inbred-lines-rils"><i class="fa fa-check"></i><b>2.1.1</b> Recombinant Inbred Lines (RILs)</a></li>
<li class="chapter" data-level="2.1.2" data-path="quantitative-genetics.html"><a href="quantitative-genetics.html#qtl-analysis-in-r"><i class="fa fa-check"></i><b>2.1.2</b> QTL analysis in R</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="quantitative-genetics.html"><a href="quantitative-genetics.html#gene-x-environment-interactions"><i class="fa fa-check"></i><b>2.2</b> Gene x Environment interactions</a></li>
<li class="chapter" data-level="2.3" data-path="quantitative-genetics.html"><a href="quantitative-genetics.html#variance-and-heritability"><i class="fa fa-check"></i><b>2.3</b> Variance and heritability</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="population-genetics.html"><a href="population-genetics.html"><i class="fa fa-check"></i><b>3</b> Population Genetics</a></li>
<li class="chapter" data-level="4" data-path="evolutionary-genetics.html"><a href="evolutionary-genetics.html"><i class="fa fa-check"></i><b>4</b> Evolutionary Genetics</a></li>
<li class="chapter" data-level="5" data-path="genetics-of-complex-diseases.html"><a href="genetics-of-complex-diseases.html"><i class="fa fa-check"></i><b>5</b> Genetics of complex diseases</a></li>
<li class="chapter" data-level="6" data-path="genetic-epidemiology.html"><a href="genetic-epidemiology.html"><i class="fa fa-check"></i><b>6</b> Genetic Epidemiology</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Statistical Genetics Analyses in R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="quantitative-genetics" class="section level1">
<h1><span class="header-section-number">2</span> Quantitative Genetics</h1>
<div id="qtl-analysis" class="section level2">
<h2><span class="header-section-number">2.1</span> QTL analysis</h2>
<p>Quantitative Trait Loci (QTL) are regions in the genome that are associated with variation in a quantitative trait. Quantitative traits are phentoypes that can be measured on a continuous scale, like height, weight, etc.</p>
<p>QTL analysis (or QTL mapping) is typically done on experimental populations to find genes which contribute to the heritability of traits. Phenotype and genetic marker data are collected from every individual in the population. The general concept of QTL mapping is that we can then calculate the correlation between genotypes and phenotypes at each marker position and test whether they show a statistically significant association.</p>
<p>Let’s consider the famous example of <span class="citation">Doebley and Stec (<a href="#ref-Doebley285">1991</a>)</span>, who assessed the variation of traits that discriminate commercial maize from its native relative teosinte. Teosinte is much smaller than maize as we know it today and one teosinte plant produces many ears, each of which has only two rows of seeds. But even though maize and teosinte look so completely different, they are still able to produce viable offspring together. <span class="citation">Doebley and Stec (<a href="#ref-Doebley285">1991</a>)</span> utilized this and crossed the two plant species to produce an F1 generation, which were in turn self-pollinated. The resulting F2 population of maize-teosinte-hybrids showed a wide range of intermediate parental morphologies. Each of the F2 offspring was then genotyped at 58 locations in the genome, so that the quantitative trait information on morphology could be correlated with the genetic map. This analysis revealed that most of the morphological variation between maize and teosinte were the result of changes in only a handful of genes, one of which is the <em>tb1</em> (<em>teosinte branched 1</em>) gene.</p>
<div id="recombinant-inbred-lines-rils" class="section level3">
<h3><span class="header-section-number">2.1.1</span> Recombinant Inbred Lines (RILs)</h3>
<p>RILs are experimental sister populations that have been produced by a very specific back-crossing scheme. The process is similar to Doebley and Stec’s crossing of maize and teosinte: two homozygous parents are crossed to produce an F1 generation. Following the laws of genetics, each offspring’s genome consists of a random combination of parental alleles and crossover (or recombination) events. Depending on the design, F1 offspring are usually either selfed or mated with a sibling to introduce another level of genetic recombination. The final generation is then inbred for many generations to obtain a collection of homozygous sister lines, each with a unique mosaic genome of parental alleles <span class="citation">(Pollard <a href="#ref-Pollard2012">2012</a>)</span>.</p>
</div>
<div id="qtl-analysis-in-r" class="section level3">
<h3><span class="header-section-number">2.1.2</span> QTL analysis in R</h3>
<div id="the-qtl-package" class="section level4">
<h4><span class="header-section-number">2.1.2.1</span> The “qtl” package</h4>
<p>The best established R package for QTL mapping is <span class="citation">Broman et al. (<a href="#ref-Broman2003">2003</a>)</span>’s <a href="http://www.rqtl.org/"><strong>qtl</strong> package</a>. It implements several techniques for finding QTLs, like Hidden Markov Models (HMM), interval mapping, Haley-Knott regression and multiple imputation. It is very well documented and comes with extensive example data and code.</p>
<p>Here, I will introduce you to a basic QTL mapping workflow using the examples given in the package documentation and refer you to more complex analysis options where applicable.</p>
<div id="installation-and-loading-the-package" class="section level5 unnumbered">
<h5>Installation and loading the package</h5>
<p>If this is the first time you are using the <strong>qtl</strong> package, you need to install it from CRAN. The following line of code checks whether you already have the package, and if not installs it.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pkg =<span class="st"> &quot;qtl&quot;</span>
if (<span class="kw">system.file</span>(<span class="dt">package =</span> pkg) ==<span class="st"> &#39;&#39;</span>) <span class="kw">install.packages</span>(pkg)</code></pre></div>
<p>You can then load the package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(qtl)</code></pre></div>
</div>
<div id="loading-the-data" class="section level5 unnumbered">
<h5>Loading the data</h5>
<p>I will be using the example data on murine hypertension that is provided in the package <span class="citation">(Sugiyama et al. <a href="#ref-Sugiyama200170">2001</a>)</span>. The <strong>summary()</strong> function shows you the main properties of the data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(hyper)
<span class="kw">summary</span>(hyper)</code></pre></div>
<pre><code>##     Backcross
## 
##     No. individuals:    250 
## 
##     No. phenotypes:     2 
##     Percent phenotyped: 100 100 
## 
##     No. chromosomes:    20 
##         Autosomes:      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 
##         X chr:          X 
## 
##     Total markers:      174 
##     No. markers:        22 8 6 20 14 11 7 6 5 5 14 5 5 5 11 6 12 4 4 4 
##     Percent genotyped:  47.7 
##     Genotypes (%):    
##           Autosomes:    BB:50.1  BA:49.9 
##        X chromosome:    BY:53.0  AY:47.0</code></pre>
<p>The <strong>plot()</strong> function produces plots showing missing genotypes, the marker positions and the distribution of phenotypes or traits. This will give you a first idea of your data.</p>
<p>The <a href="http://www.rqtl.org/tutorials/rqtltour.pdf">package manual</a> includes a description of various additional plotting functions, which I won’t cover here. I also advise to examine each object with <strong>head()</strong> or <strong>summary()</strong> after you ran a function to get a feel for your data and the various steps you are taking in the analysis.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(hyper)</code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-4-1.png" width="768" style="display: block; margin: auto;" /></p>
</div>
<div id="genetic-map-estimation" class="section level5 unnumbered">
<h5>Genetic map estimation</h5>
<p>Before we proceed with the analysis, I typically recommend to replace the existing genetic map with an estimated one to reduce the potential errors. The genetic map represents all markers on a chromosome in a linear fashion. The <strong>est.map()</strong> function applies a Hidden Markov Model <span class="citation">(E. S. Lander and Green <a href="#ref-Lander01041987">1987</a>)</span> to estimate the map with an assumed genotyping error rate (<em>error.prob</em>).</p>
<p>Here, we can also specifiy the mapping function (<em>map.function</em>) that we want to use to convert genetic distance to recombination fraction. The distance between two markers is usually given as a unit of genetic linkage, called <em>centimorgan (cM)</em> One cM represents the distance with an average of 0.01 crossover events in one generation (i.e. 1% recombination). However, this representation of distance underestimates the actual recombination fraction, which is inherently not additive. With increasing distance the chance of double crossovers increases, so that they are in a way “invisible” to the traditional estimation of recombination distance.</p>
<p>Another reason why genetic maps based on recombination are biased is crossover interference, which described the phenomenon that a crossover event reduces the likelihood of another recombination event occur close by.</p>
<p>To correct for such biases, we can choose from the following mapping functions:</p>
<ul>
<li><strong>Haldane’s</strong> is the simplest mapping function and assumes a Poisson distribution for crossover events and does not consider interference.</li>
<li><strong>Kosambi’s</strong> mapping function also considers interference and double crossovers but it can not calculate joint recombination probabilities for more than three loci.</li>
<li><strong>Carter-Falconer’s</strong> mapping function can be extended to more complex interference rates.</li>
<li><strong>Morgan’s</strong> mapping function assumes complete interference.</li>
</ul>
<p>The two most widely used mapping functions are Haldane’s (the default) and Kosambi’s. For this example, using Haldane’s should be sufficient. Because our example is a backcross, we can assume no interference, meaning that all crossovers are independent <span class="citation">(Lynch and Walsh <a href="#ref-lynch1998genetics">1998</a>)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">newmap &lt;-<span class="st"> </span><span class="kw">est.map</span>(hyper, <span class="dt">error.prob =</span> <span class="fl">0.0001</span>, <span class="dt">map.function =</span> <span class="st">&quot;haldane&quot;</span>)
hyper &lt;-<span class="st"> </span><span class="kw">replace.map</span>(hyper, newmap)</code></pre></div>
<p>We can now estimate the recombination fractions between all pairs of markers. The <strong>est.rf()</strong> function also calculates the LOD scores. LOD stands for “likelihood of the odds” and is a measure of linkage. In QTL mapping we calculate LOD scores for the genetic markers and a threshold, above which we consider a QTL statistically significant in its association with the trait.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hyper &lt;-<span class="st"> </span><span class="kw">est.rf</span>(hyper)</code></pre></div>
<p>The <strong>calc.errorlod()</strong> function calculates the genotyping errors according to <span class="citation">Lincoln and Lander (<a href="#ref-Lincoln1992604">1992</a>)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hyper &lt;-<span class="st"> </span><span class="kw">calc.errorlod</span>(hyper, <span class="dt">error.prob =</span> <span class="fl">0.0001</span>)</code></pre></div>
</div>
<div id="finding-qtls" class="section level5 unnumbered">
<h5>Finding QTLs</h5>
<p>Now, we can proceed with the central step: mapping the QTLs.</p>
<p>The core of R/qtl is a set of functions which make use of the hidden Markov model (HMM) technology to calculate QTL genotype probabilities, to simulate from the joint genotype distribution and to calculate the most likely sequence of underlying genotypes (all conditional on the observed marker data). This is done in a quite general way, with possible allowance for the presence of genotyping errors. Of course, for convenience we assume no crossover interference. The function calc.genoprob calculates QTL genotype probabilities, conditional on the available marker data. These are needed for most of the QTL mapping functions. The argument step indicates the step size (in cM) at which the probabilities are calculated, and determines the step size at which later LOD scores are calculated.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hyper &lt;-<span class="st"> </span><span class="kw">calc.genoprob</span>(hyper, <span class="dt">step =</span> <span class="dv">1</span>, <span class="dt">error.prob =</span> <span class="fl">0.0001</span>)</code></pre></div>
<p>We may now use the function scanone to perform a single-QTL genome scan with a normal model. We may use maximum likelihood via the EM algorithm (Lander and Botstein 1989) or use Haley-Knott regression (Haley and Knott 1992).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">out.em &lt;-<span class="st"> </span><span class="kw">scanone</span>(hyper)
out.hk &lt;-<span class="st"> </span><span class="kw">scanone</span>(hyper, <span class="dt">method =</span> <span class="st">&quot;hk&quot;</span>)</code></pre></div>
<p>We may also use the multiple imputation method of Sen and Churchill (2001). This requires that we first use sim.geno to simulate from the joint genotype distribution, given the observed marker data. Again, the argument step indicates the step size at which the imputations are performed and determines the step size at which LOD scores will be calculated. The n.draws indicates the number of imputations to perform. Larger values give more precise results but require considerably more computer memory and computation time.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hyper &lt;-<span class="st"> </span><span class="kw">sim.geno</span>(hyper, <span class="dt">step =</span> <span class="dv">2</span>, <span class="dt">n.draws =</span> <span class="dv">16</span>, <span class="dt">error.prob =</span> <span class="fl">0.01</span>)
out.imp &lt;-<span class="st"> </span><span class="kw">scanone</span>(hyper, <span class="dt">method =</span> <span class="st">&quot;imp&quot;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(out.em)
<span class="kw">plot</span>(out.hk, <span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(out.imp, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>)
<span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;EM algorithm&quot;</span>, <span class="st">&quot;Haley-Knott&quot;</span>, <span class="st">&quot;Mult. imputation&quot;</span>), <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;black&quot;</span>, <span class="st">&quot;blue&quot;</span>, <span class="st">&quot;red&quot;</span>), <span class="dt">lty =</span> <span class="dv">1</span>, <span class="dt">lwd =</span> <span class="dv">3</span>)</code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<p>The function scanone may also be used to perform a permutation test to get a genome-wide LOD significance threshold. For Haley-Knott regression, this can be quite fast.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">operm.hk &lt;-<span class="st"> </span><span class="kw">scanone</span>(hyper, <span class="dt">method =</span> <span class="st">&quot;hk&quot;</span>, <span class="dt">n.perm =</span> <span class="dv">1000</span>)</code></pre></div>
<pre><code>## Doing permutation in batch mode ...</code></pre>
<p>The permutation output has class “scanoneperm”. The function summary.scanoneperm can be used to get significance thresholds.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(operm.hk, <span class="dt">alpha =</span> <span class="fl">0.05</span>)</code></pre></div>
<pre><code>## LOD thresholds (1000 permutations)
##     lod
## 5% 2.78</code></pre>
<p>In addition, if the permutations results are included in a call to summary.scanone, you can estimated genome-scanadjusted p-values for inferred QTL, and can get a report of all chromosomes meeting a certain significance level, with the corresponding LOD threshold calculated automatically.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(out.hk, <span class="dt">perms=</span>operm.hk, <span class="dt">alpha =</span> <span class="fl">0.05</span>, <span class="dt">pvalues =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>##          chr  pos  lod  pval
## c1.loc96   1 99.3 3.78 0.006
## D4Mit164   4 41.6 8.10 0.000</code></pre>
<p>The function scantwo performs a two-dimensional genome scan with a two-QTL model. For every pair of positions, it calculates a LOD score for the full model (two QTL plus interaction) and a LOD score for the additive model (two QTL but no interaction). This be quite time consuming, and so you may wish to do the calculations on a coarser grid. One can also use method=“em” or method=“imp”, but they are even more time consuming.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hyper &lt;-<span class="st"> </span><span class="kw">calc.genoprob</span>(hyper, <span class="dt">step =</span> <span class="dv">5</span>, <span class="dt">error.prob =</span> <span class="fl">0.01</span>)
out2.hk &lt;-<span class="st"> </span><span class="kw">scantwo</span>(hyper, <span class="dt">method =</span> <span class="st">&quot;hk&quot;</span>)</code></pre></div>
<pre><code>##  --Running scanone
##  --Running scantwo
##  (1,1)
##  (1,2)
##  (1,3)
##  (1,4)
##  (1,5)
##  (1,6)
##  (1,7)
##  (1,8)
##  (1,9)
##  (1,10)
##  (1,11)
##  (1,12)
##  (1,13)
##  (1,14)
##  (1,15)
##  (1,16)
##  (1,17)
##  (1,18)
##  (1,19)
##  (1,X)
##  (2,2)
##  (2,3)
##  (2,4)
##  (2,5)
##  (2,6)
##  (2,7)
##  (2,8)
##  (2,9)
##  (2,10)
##  (2,11)
##  (2,12)
##  (2,13)
##  (2,14)
##  (2,15)
##  (2,16)
##  (2,17)
##  (2,18)
##  (2,19)
##  (2,X)
##  (3,3)
##  (3,4)
##  (3,5)
##  (3,6)
##  (3,7)
##  (3,8)
##  (3,9)
##  (3,10)
##  (3,11)
##  (3,12)
##  (3,13)
##  (3,14)
##  (3,15)
##  (3,16)
##  (3,17)
##  (3,18)
##  (3,19)
##  (3,X)
##  (4,4)
##  (4,5)
##  (4,6)
##  (4,7)
##  (4,8)
##  (4,9)
##  (4,10)
##  (4,11)
##  (4,12)
##  (4,13)
##  (4,14)
##  (4,15)
##  (4,16)
##  (4,17)
##  (4,18)
##  (4,19)
##  (4,X)
##  (5,5)
##  (5,6)
##  (5,7)
##  (5,8)
##  (5,9)
##  (5,10)
##  (5,11)
##  (5,12)
##  (5,13)
##  (5,14)
##  (5,15)
##  (5,16)
##  (5,17)
##  (5,18)
##  (5,19)
##  (5,X)
##  (6,6)
##  (6,7)
##  (6,8)
##  (6,9)
##  (6,10)
##  (6,11)
##  (6,12)
##  (6,13)
##  (6,14)
##  (6,15)
##  (6,16)
##  (6,17)
##  (6,18)
##  (6,19)
##  (6,X)
##  (7,7)
##  (7,8)
##  (7,9)
##  (7,10)
##  (7,11)
##  (7,12)
##  (7,13)
##  (7,14)
##  (7,15)
##  (7,16)
##  (7,17)
##  (7,18)
##  (7,19)
##  (7,X)
##  (8,8)
##  (8,9)
##  (8,10)
##  (8,11)
##  (8,12)
##  (8,13)
##  (8,14)
##  (8,15)
##  (8,16)
##  (8,17)
##  (8,18)
##  (8,19)
##  (8,X)
##  (9,9)
##  (9,10)
##  (9,11)
##  (9,12)
##  (9,13)
##  (9,14)
##  (9,15)
##  (9,16)
##  (9,17)
##  (9,18)
##  (9,19)
##  (9,X)
##  (10,10)
##  (10,11)
##  (10,12)
##  (10,13)
##  (10,14)
##  (10,15)
##  (10,16)
##  (10,17)
##  (10,18)
##  (10,19)
##  (10,X)
##  (11,11)
##  (11,12)
##  (11,13)
##  (11,14)
##  (11,15)
##  (11,16)
##  (11,17)
##  (11,18)
##  (11,19)
##  (11,X)
##  (12,12)
##  (12,13)
##  (12,14)
##  (12,15)
##  (12,16)
##  (12,17)
##  (12,18)
##  (12,19)
##  (12,X)
##  (13,13)
##  (13,14)
##  (13,15)
##  (13,16)
##  (13,17)
##  (13,18)
##  (13,19)
##  (13,X)
##  (14,14)
##  (14,15)
##  (14,16)
##  (14,17)
##  (14,18)
##  (14,19)
##  (14,X)
##  (15,15)
##  (15,16)
##  (15,17)
##  (15,18)
##  (15,19)
##  (15,X)
##  (16,16)
##  (16,17)
##  (16,18)
##  (16,19)
##  (16,X)
##  (17,17)
##  (17,18)
##  (17,19)
##  (17,X)
##  (18,18)
##  (18,19)
##  (18,X)
##  (19,19)
##  (19,X)
##  (X,X)</code></pre>
<p>The output of scantwo has class “scantwo”; there are functions for obtaining summaries and plots, of course. The summary function considers each pair of chromosomes, and calculates the maximum LOD score for the full model (Mf ) and the maximum LOD score for the additive model (Ma). These two models are allowed to be maximized at different positions. We futher calculate a LOD score for a test of epistasis, Mi = Mf − Ma, and two LOD scores that concern evidence for a second QTL: Mfv1 is the LOD score comparing the full model to the best single-QTL model and Mav1 is the LOD score comparing the additive model to the best single-QTL model. In the summary, we must provide five thresholds, for Mf , Mfv1, Mi , Ma, and Mav1, respectively. Call these Tf , Tfv1, Ti , Ta, and Tav1. We then report those pairs of chromosomes for which at least one of the following holds: 7 • Mf ≥ Tf and (Mfv1 ≥ Tfv1 or Mi ≥ Ti) • Ma ≥ Ta and Mav1 ≥ Tav1 The thresholds can be obtained by a permutation test (see below), but this is extremely time-consuming. For a mouse backcross, we suggest the thresholds (6.0, 4.7, 4.4, 4.7, 2.6) for the full, conditional-interactive, interaction, additive, and conditional-additive LOD scores, respectively. For a mouse intercross, we suggest the thresholds (9.1, 7.1, 6.3, 6.3, 3.3) for the full, conditional-interactive, interaction, additive, and conditional-additive LOD scores, respectively. These were obtained by 10,000 simulations of crosses with 250 individuals, markers at a 10 cM spacing, and analysis by Haley-Knott regression.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(out2.hk, <span class="dt">thresholds=</span><span class="kw">c</span>(<span class="fl">6.0</span>, <span class="fl">4.7</span>, <span class="fl">4.4</span>, <span class="fl">4.7</span>, <span class="fl">2.6</span>))</code></pre></div>
<pre><code>##         pos1f pos2f lod.full lod.fv1 lod.int     pos1a pos2a lod.add
## c1 :c4   78.3  45.0    13.72    6.64   0.228      78.3  45.0   13.49
## c2 :c19  62.7   0.0     6.80    5.10   3.546      72.7   0.0    3.25
## c6 :c15 100.0  30.5     7.27    5.09   2.925      55.0  40.5    4.35
## c12:c19   1.1  35.0     6.68    4.98   4.220       1.1   0.0    2.45
##         lod.av1
## c1 :c4    6.411
## c2 :c19   1.552
## c6 :c15   2.168
## c12:c19   0.758</code></pre>
<p>The appropriate decision rule is not yet completely clear. I am inclined to ignore Mi and to choose genome-wide thresholds for the other four based on a permutation, using a common significance level for all four. Mi would be ignored if we gave it a very large threshold, as follows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(out2.hk, <span class="dt">thresholds=</span><span class="kw">c</span>(<span class="fl">6.0</span>, <span class="fl">4.7</span>, <span class="ot">Inf</span>, <span class="fl">4.7</span>, <span class="fl">2.6</span>))</code></pre></div>
<pre><code>##         pos1f pos2f lod.full lod.fv1 lod.int     pos1a pos2a lod.add
## c1 :c4   78.3  45.0    13.72    6.64   0.228      78.3  45.0   13.49
## c2 :c19  62.7   0.0     6.80    5.10   3.546      72.7   0.0    3.25
## c6 :c15 100.0  30.5     7.27    5.09   2.925      55.0  40.5    4.35
## c12:c19   1.1  35.0     6.68    4.98   4.220       1.1   0.0    2.45
##         lod.av1
## c1 :c4    6.411
## c2 :c19   1.552
## c6 :c15   2.168
## c12:c19   0.758</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(out2.hk)</code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>By default, the upper-left triangle contains epistasis LOD scores and the lower-right triangle contains the LOD scores for the full model. The color scale on the right indicates separate scales for the epistasis and joint LOD scores (on the left and right, respectively).</p>
<p>The function max.scantwo returns the two-locus positions with the maximum LOD score for the full and additive models</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">max</span>(out2.hk)</code></pre></div>
<pre><code>##       pos1f pos2f lod.full lod.fv1 lod.int     pos1a pos2a lod.add lod.av1
## c1:c4  78.3    45     13.7    6.64   0.228      78.3    45    13.5    6.41</code></pre>
<p>One may also use scantwo to perform permutation tests in order to obtain genome-wide LOD significance thresholds. These can be extremely time consuming, though with the Haley-Knott regression and multiple imputation methods, there is a trick that may be used in some cases to dramatically speed things up. So we’ll try 100 permutations by the Haley-Knott regression method and hope that your computer is sufficiently fast.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">operm2.hk &lt;-<span class="st"> </span><span class="kw">scantwo</span>(hyper, <span class="dt">method =</span> <span class="st">&quot;hk&quot;</span>, <span class="dt">n.perm =</span> <span class="dv">100</span>)</code></pre></div>
<pre><code>## Doing permutation in batch mode ...</code></pre>
<p>We can again use summary to get LOD thresholds.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(operm2.hk)</code></pre></div>
<pre><code>## bp (100 permutations)
##     full  fv1  int  add  av1  one
## 5%  5.65 4.80 4.37 4.49 2.40 2.62
## 10% 5.31 4.31 3.96 3.93 2.08 2.24</code></pre>
<p>And again these may be used in the summary of the scantwo output to calculate thresholds and p-values. If you want to ignore the LOD score for the interaction in the rule about what chromosome pairs to report, give α = 0, corresponding to a threshold T = ∞.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(out2.hk, <span class="dt">perms =</span> operm2.hk, <span class="dt">pvalues =</span> <span class="ot">TRUE</span>, <span class="dt">alphas =</span> <span class="kw">c</span>(<span class="fl">0.05</span>, <span class="fl">0.05</span>, <span class="dv">0</span>, <span class="fl">0.05</span>, <span class="fl">0.05</span>))</code></pre></div>
<pre><code>##         pos1f pos2f lod.full pval lod.fv1 pval lod.int pval     pos1a
## c1 :c4   78.3  45.0    13.72 0.00    6.64 0.00   0.228 1.00      78.3
## c2 :c19  62.7   0.0     6.80 0.02    5.10 0.01   3.546 0.21      72.7
## c3 :c3   67.2  72.2     4.82 0.23    4.05 0.15   0.180 1.00      67.2
## c6 :c15 100.0  30.5     7.27 0.00    5.09 0.01   2.925 0.50      55.0
## c12:c19   1.1  35.0     6.68 0.02    4.98 0.03   4.220 0.08       1.1
##         pos2a lod.add pval lod.av1 pval
## c1 :c4   45.0   13.49 0.00   6.411 0.00
## c2 :c19   0.0    3.25 0.33   1.552 0.45
## c3 :c3   82.2    4.64 0.04   3.866 0.00
## c6 :c15  40.5    4.35 0.07   2.168 0.09
## c12:c19   0.0    2.45 0.71   0.758 1.00</code></pre>
<p>You can’t really trust these results. Haley-Knott regression performs poorly in the case of selective genotyping (as with the hyper data). Standard interval mapping or imputation would be better, but Haley-Knott regression has the advantage of speed, which is the reason we use it here.</p>
<p>Finally, we consider the fit of multiple-QTL models. Currently, only multiple imputation and Haley-Knott regression has been implemented. We use multiple imputation here, as Haley-Knott regression performs poorly in the case of selective genotyping, which was used for the hyper data. We first create a QTL object using the function makeqtl, with five QTL at specified, fixed positions.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chr &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">15</span>)
pos &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">50</span>, <span class="dv">76</span>, <span class="dv">30</span>, <span class="dv">70</span>, <span class="dv">20</span>)
qtl &lt;-<span class="st"> </span><span class="kw">makeqtl</span>(hyper, chr, pos)</code></pre></div>
<p>Finally, we use the function fitqtl to fit a model with five QTL, and allowing the QTL on chr 6 and 15 to interact.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">out.fitqtl &lt;-<span class="st"> </span><span class="kw">fitqtl</span>(hyper, <span class="dt">qtl=</span>qtl, <span class="dt">formula=</span>y -<span class="st"> </span>Q1 +<span class="st"> </span>Q2 +<span class="st"> </span>Q3 +<span class="st"> </span>Q4 +<span class="st"> </span>Q5 +<span class="st"> </span>Q4:Q5)
<span class="kw">summary</span>(out.fitqtl)</code></pre></div>
</div>
<div id="covariates-in-qtl-models" class="section level5 unnumbered">
<h5>Covariates in QTL models</h5>
</div>
</div>
</div>
</div>
<div id="gene-x-environment-interactions" class="section level2">
<h2><span class="header-section-number">2.2</span> Gene x Environment interactions</h2>
</div>
<div id="variance-and-heritability" class="section level2">
<h2><span class="header-section-number">2.3</span> Variance and heritability</h2>

</div>
</div>
<h3> Genetic Epidemiology</h3>
<div id="refs" class="references">
<div id="ref-Doebley285">
<p>Doebley, J, and A Stec. 1991. “Genetic Analysis of the Morphological Differences Between Maize and Teosinte.” <em>Genetics</em> 129 (1). Genetics: 285–95. <a href="http://www.genetics.org/content/129/1/285" class="uri">http://www.genetics.org/content/129/1/285</a>.</p>
</div>
<div id="ref-Pollard2012">
<p>Pollard, Daniel A. 2012. “Design and Construction of Recombinant Inbred Lines.” In <em>Quantitative Trait Loci (Qtl): Methods and Protocols</em>, edited by Scott A. Rifkin, 31–39. Totowa, NJ: Humana Press. doi:<a href="https://doi.org/10.1007/978-1-61779-785-9_3">10.1007/978-1-61779-785-9_3</a>.</p>
</div>
<div id="ref-Broman2003">
<p>Broman, Karl W., Hao Wu, Saunak Sen, and Gary A. Churchill. 2003. “R/Qtl: QTL Mapping in Experimental Crosses.” <em>Bioinformatics</em> 19: 889–90.</p>
</div>
<div id="ref-Sugiyama200170">
<p>Sugiyama, Fumihiro, Gary A. Churchill, David C. Higgins, Conrado Johns, Konstatinos P. Makaritsis, Haralambos Gavras, and Beverly Paigen. 2001. “Concordance of Murine Quantitative Trait Loci for Salt-Induced Hypertension with Rat and Human Loci.” <em>Genomics</em> 71 (1): 70–77. doi:<a href="https://doi.org/http://dx.doi.org/10.1006/geno.2000.6401">http://dx.doi.org/10.1006/geno.2000.6401</a>.</p>
</div>
<div id="ref-Lander01041987">
<p>Lander, E S, and P Green. 1987. “Construction of Multilocus Genetic Linkage Maps in Humans.” <em>Proceedings of the National Academy of Sciences</em> 84 (8): 2363–7. <a href="http://www.pnas.org/content/84/8/2363.abstract" class="uri">http://www.pnas.org/content/84/8/2363.abstract</a>.</p>
</div>
<div id="ref-lynch1998genetics">
<p>Lynch, M., and B. Walsh. 1998. <em>Genetics and Analysis of Quantitative Traits</em>. Sinauer. <a href="https://books.google.de/books?id=UhCCQgAACAAJ" class="uri">https://books.google.de/books?id=UhCCQgAACAAJ</a>.</p>
</div>
<div id="ref-Lincoln1992604">
<p>Lincoln, Stephen E., and Eric S. Lander. 1992. “Systematic Detection of Errors in Genetic Linkage Data.” <em>Genomics</em> 14 (3): 604–10. doi:<a href="https://doi.org/http://dx.doi.org/10.1016/S0888-7543(05)80158-2">http://dx.doi.org/10.1016/S0888-7543(05)80158-2</a>.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="introduction-to-statistical-genetics.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="population-genetics.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": ["_main.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
